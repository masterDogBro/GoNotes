# LRU 缓存淘汰策略

## 实现内容：

​	LRU键值对缓存结构体（单机非并发）

## LRU(Least Recently Used)策略特性：

​	最近最少使用，相对于仅考虑时间因素的 FIFO 和仅考虑访问频率的 LFU，LRU 算法可以认为是相对平衡的一种淘汰算法。LRU 认为，如果数据最近被访问过，那么将来被访问的概率也会更高。LRU 算法的实现非常简单，维护一个队列，如果某条记录被访问了，则移动到队尾，那么队首则是最近最少访问的数据，淘汰该条记录即可。

## Redis实际使用**近似LRU算法**，为什么？

​	LRU 算法需要用链表管理所有的数据，会造成大量额外的空间消耗。除此之外，大量的节点被访问就会带来频繁的链表节点移动操作，从而降低了 Redis 性能。所以 Redis 对该算法做了简化，Rdedis LRU 算法并不是真正的 LRU，Redis 通过对少量的 key 采样，并淘汰采样的数据中最久没被访问过的 key。

​	[Redis 为何使用近似 LRU 算法淘汰数据，而不是真实 LRU？_51CTO博客_redis有几种数据淘汰策略](https://blog.51cto.com/MageByte/5286087)

## 算法实现

### 核心数据结构

![implement lru algorithm with golang](https://tuchuang-1318639513.cos.ap-beijing.myqcloud.com/images/202310131356092.jpeg)

字典(map)的意义

​	存储键值对映射关系，让**键值对按key查找**和**插入新键值对**的时间复杂度为O(1)（常数级）

双向链表(double linked list)的意义

​	**移动某个被访问到的键值对到队尾**和**在队尾新增、删除一条记录**的时间复杂度为O(1)

### 必要方法实现

​	查找：通过字典确定双向链表的节点，然后将节点移动到队尾。当缓存被命中执行的逻辑。

​	删除：缓存淘汰的实际执行的逻辑。

​	新增/修改：当键存在，更新键值移到队尾（已有的缓存被更新）；当键不存在，在双向队列添加新纪录（缓存内不存在，从数据库访问，并写入缓存）。

### 非必要方法实现

​	获取长度：返回双向链表长度